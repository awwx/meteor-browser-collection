// Generated by CoffeeScript 1.4.0
(function() {
  var collections, db, each_sql_result, idMap, idOf, result_as_array, _when,
    __slice = [].slice;

  _when = this.when;

  db = openDatabase('Meteor.BrowserCollection', '', '', 1024 * 1024, db);

  if (db.version === '') {
    db.changeVersion('', '1', (function(tx) {
      tx.executeSql('CREATE TABLE documents (\
           id TEXT NOT NULL PRIMARY KEY,\
           collection TEXT NOT NULL,\
           document TEXT NOT NULL\
         )\
        ');
      return tx.executeSql('CREATE INDEX collections ON documents (collection)');
    }), (function(error) {
      return console.log('create database error', error);
    }), (function() {
      return console.log('create database success');
    }));
  }

  collections = {};

  Meteor.BrowserMsg.listen({
    'Meteor.BrowserCollection.single': function(collection_name, doc_id) {
      var _ref;
      return (_ref = collections[collection_name]) != null ? _ref._reload_single(doc_id) : void 0;
    },
    'Meteor.BrowserCollection.reloadAll': function(collection_name) {
      var _ref;
      return (_ref = collections[collection_name]) != null ? _ref._reload_all() : void 0;
    }
  });

  Meteor.BrowserSQLCollection = function(name, cb) {
    if (collections[name] != null) {
      throw new Error('a BrowserCollection with this name has already been created: ' + name);
    }
    this._name = name;
    this._localCollection = new LocalCollection();
    collections[name] = this;
    this._load(cb);
    return void 0;
  };

  each_sql_result = function(result, callback) {
    var i, _i, _ref, _results;
    _results = [];
    for (i = _i = 0, _ref = result.rows.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
      _results.push(callback(result.rows.item(i)));
    }
    return _results;
  };

  result_as_array = function(result) {
    var a, i, _i, _ref;
    a = [];
    for (i = _i = 0, _ref = result.rows.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
      a.push(result.rows.item(i));
    }
    return a;
  };

  idOf = function(doc) {
    return doc._id;
  };

  idMap = function(arrayOfDocs) {
    var doc, result, _i, _len;
    result = {};
    for (_i = 0, _len = arrayOfDocs.length; _i < _len; _i++) {
      doc = arrayOfDocs[_i];
      result[idOf(doc)] = doc;
    }
    return result;
  };

  _.extend(Meteor.BrowserSQLCollection.prototype, {
    _load: function(cb) {
      var _this = this;
      return db.transaction((function(tx) {
        return tx.executeSql('SELECT document FROM documents WHERE collection=?', [_this._name], (function(tx, result) {
          return each_sql_result(result, function(row) {
            return _this._localCollection.insert(JSON.parse(row.document));
          });
        }));
      }), (function(error) {
        return console.log(error);
      }), (function() {
        return typeof cb === "function" ? cb() : void 0;
      }));
    },
    _cache_set: function(doc_id, doc) {
      if (doc != null) {
        if (this._localCollection.findOne(doc._id) != null) {
          this._localCollection.update(doc._id, doc);
        } else {
          this._localCollection.insert(doc);
        }
      } else {
        this._localCollection.remove(doc_id);
      }
      return void 0;
    },
    _reload_single: function(doc_id) {
      var doc,
        _this = this;
      doc = null;
      return db.transaction((function(tx) {
        return tx.executeSql('SELECT document FROM documents WHERE collection=? AND id=?', [_this._name, doc_id], (function(tx, result) {
          if (result.rows.length === 1) {
            return doc = JSON.parse(result.rows.item(0).document);
          }
        }));
      }), (function(error) {
        return console.log(error);
      }), (function() {
        return _this._cache_set(doc_id, doc);
      }));
    },
    _fetch_all_docs: function(tx, cb) {
      var _this = this;
      return tx.executeSql('SELECT document FROM documents WHERE collection=?', [this._name], (function(tx, result) {
        var docs, i, _i, _ref;
        docs = [];
        for (i = _i = 0, _ref = result.rows.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          docs.push(JSON.parse(result.rows.item(i).document));
        }
        return cb(docs);
      }));
    },
    _store_doc: function(tx, doc) {
      return tx.executeSql('UPDATE documents SET document=? WHERE id=?', [JSON.stringify(doc), doc._id]);
    },
    _delete_doc: function(tx, doc_id) {
      return tx.executeSql('DELETE FROM documents WHERE id=?', [doc_id]);
    },
    _reload_all: function() {
      var docs,
        _this = this;
      docs = null;
      return db.transaction((function(tx) {
        return _this._fetch_all_docs(tx, function(_docs) {
          return docs = _docs;
        });
      }), (function(error) {
        return console.log(error);
      }), (function() {
        var newResults, oldResults;
        oldResults = idMap(_this._localCollection.find().fetch());
        newResults = idMap(docs);
        return LocalCollection._diffQueryUnordered(oldResults, newResults, {
          added: function(newDoc) {
            return _this._localCollection.insert(newDoc);
          },
          changed: function(newDoc) {
            return _this._localCollection.update(newDoc._id, newDoc);
          },
          removed: function(oldDoc) {
            return _this._localCollection.remove(oldDoc._id);
          }
        });
      }));
    },
    insert: function(doc, callback) {
      var _this = this;
      if (doc._id != null) {
        throw new Error('inserted doc should not yet have an _id attribute');
      }
      doc._id = LocalCollection.uuid();
      db.transaction((function(tx) {
        return tx.executeSql('INSERT INTO documents (id, collection, document) VALUES (?, ?, ?)', [doc._id, _this._name, JSON.stringify(doc)]);
      }), (function(error) {
        console.log('insert transaction error', error);
        if (typeof callback === "function") {
          callback(error);
        }
        return void 0;
      }), (function() {
        _this._localCollection.insert(doc);
        Meteor.BrowserMsg.send('Meteor.BrowserCollection.single', _this._name, doc._id);
        if (typeof callback === "function") {
          callback();
        }
        return void 0;
      }));
      return doc._id;
    },
    find: function() {
      var arg, _ref;
      arg = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      return (_ref = this._localCollection).find.apply(_ref, arg);
    },
    findOne: function() {
      var arg, _ref;
      arg = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      return (_ref = this._localCollection).findOne.apply(_ref, arg);
    },
    _update_single: function(doc_id, modifier, options, callback) {
      var doc,
        _this = this;
      doc = null;
      return db.transaction((function(tx) {
        return tx.executeSql('SELECT document FROM documents WHERE id=?', [doc_id], (function(tx, result) {
          if (result.rows.length !== 1) {
            return;
          }
          doc = JSON.parse(result.rows.item(0).document);
          LocalCollection._modify(doc, modifier);
          return _this._store_doc(tx, doc);
        }));
      }), (function(error) {
        console.log('modify transaction error', error);
        if (typeof callback === "function") {
          callback(error);
        }
        return void 0;
      }), (function() {
        _this._cache_set(doc_id, doc);
        Meteor.BrowserMsg.send('Meteor.BrowserCollection.single', _this._name, doc_id);
        if (typeof callback === "function") {
          callback();
        }
        return void 0;
      }));
    },
    _update_multiple: function(selector, modifier, options, callback) {
      var compiledSelector, modified_docs,
        _this = this;
      compiledSelector = LocalCollection._compileSelector(selector);
      modified_docs = [];
      return db.transaction((function(tx) {
        return _this._fetch_all_docs(tx, function(docs) {
          var doc, _i, _len;
          for (_i = 0, _len = docs.length; _i < _len; _i++) {
            doc = docs[_i];
            if (compiledSelector(doc)) {
              LocalCollection._modify(doc, modifier);
              _this._store_doc(tx, doc);
              modified_docs.push(doc);
              if (!(options != null ? options.multi : void 0)) {
                break;
              }
            }
          }
          return void 0;
        });
      }), (function(error) {
        console.log('update transaction error', error);
        if (typeof callback === "function") {
          callback();
        }
        return void 0;
      }), (function() {
        var doc, _i, _len;
        for (_i = 0, _len = modified_docs.length; _i < _len; _i++) {
          doc = modified_docs[_i];
          _this._localCollection.update(doc._id, doc);
        }
        Meteor.BrowserMsg.send('Meteor.BrowserCollection.reloadAll', _this._name);
        if (typeof callback === "function") {
          callback();
        }
        return void 0;
      }));
    },
    update: function(selector, modifier, options, callback) {
      if (_.isFunction(options)) {
        callback = options;
        options = {};
      }
      if (LocalCollection._selectorIsId(selector)) {
        this._update_single(selector, modifier, options, callback);
      } else {
        this._update_multiple(selector, modifier, options, callback);
      }
      return void 0;
    },
    _remove_single: function(doc_id, callback) {
      var _this = this;
      return db.transaction((function(tx) {
        return _this._delete_doc(tx, doc_id);
      }), (function(error) {
        console.log('remove transaction error', error);
        if (typeof callback === "function") {
          callback();
        }
        return void 0;
      }), (function(tx, result) {
        _this._localCollection.remove(doc_id);
        Meteor.BrowserMsg.send('Meteor.BrowserCollection.single', _this._name, doc_id);
        if (typeof callback === "function") {
          callback();
        }
        return void 0;
      }));
    },
    _remove_multiple: function(selector, callback) {
      var compiledSelector, deleted,
        _this = this;
      compiledSelector = LocalCollection._compileSelector(selector);
      deleted = [];
      return db.transaction((function(tx) {
        return _this._fetch_all_docs(tx, function(docs) {
          var doc, _i, _len;
          for (_i = 0, _len = docs.length; _i < _len; _i++) {
            doc = docs[_i];
            if (compiledSelector(doc)) {
              _this._delete_doc(tx, doc._id);
              deleted.push(doc._id);
            }
          }
          return void 0;
        });
      }), (function(error) {
        console.log('remove transaction error', error);
        if (typeof callback === "function") {
          callback(error);
        }
        return void 0;
      }), (function() {
        var doc_id, _i, _len;
        for (_i = 0, _len = deleted.length; _i < _len; _i++) {
          doc_id = deleted[_i];
          _this._localCollection.remove(doc_id);
        }
        Meteor.BrowserMsg.send('Meteor.BrowserCollection.reloadAll', _this._name);
        if (typeof callback === "function") {
          callback();
        }
        return void 0;
      }));
    },
    remove: function(selector, callback) {
      if (selector == null) {
        return;
      }
      if (LocalCollection._selectorIsId(selector)) {
        this._remove_single(selector, callback);
      } else {
        this._remove_multiple(selector, callback);
      }
      return void 0;
    }
  });

  Meteor.BrowserSQLCollection.erase = function() {
    var done;
    done = _when.defer();
    if (!_.isEmpty(collections)) {
      throw new Error("call erase() before opening any collections");
    }
    db.transaction((function(tx) {
      return tx.executeSql('DELETE FROM documents');
    }), (function(error) {
      console.log('erase transaction error', error);
      return done.reject(error);
    }), (function() {
      console.log('erase transaction success');
      return done.resolve();
    }));
    return done.promise;
  };

  Meteor.BrowserSQLCollection.reset = function() {
    return collections = {};
  };

}).call(this);
