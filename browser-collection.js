// Generated by CoffeeScript 1.4.0
(function() {
  var IndexedStore, SQLStore, collections, each_sql_result, idMap, idOf, request_to_promise, result_as_array, store, _when,
    __slice = [].slice;

  _when = this.when;

  request_to_promise = function(req) {
    var pend;
    pend = _when.defer();
    req.onerror = function(event) {
      return pend.reject();
    };
    req.onsuccess = function(event) {
      return pend.resolve(req.result);
    };
    return pend.promise;
  };

  IndexedStore = (function() {

    function IndexedStore() {}

    IndexedStore.prototype.delete_database = function(database_name) {
      return request_to_promise(window.indexedDB.deleteDatabase(database_name));
    };

    IndexedStore.prototype.open_database = function(database_name, version, onUpgradeNeeded) {
      var req;
      req = window.indexedDB.open(database_name, version);
      req.onupgradeneeded = function(event) {
        return onUpgradeNeeded(event.target.result);
      };
      return request_to_promise(req);
    };

    IndexedStore.prototype.transaction = function(withTransaction) {
      var deferred, tx,
        _this = this;
      deferred = _when.defer();
      tx = this.idb.transaction(['documents'], 'readwrite');
      tx.oncomplete = function() {
        return deferred.resolve();
      };
      tx.onerror = function(event) {
        return deferred.reject(event.target.errorCode);
      };
      _when(withTransaction(tx), null, (function(error) {
        return deferred.reject(error);
      }));
      return deferred.promise;
    };

    IndexedStore.prototype.get = function(store, key) {
      return request_to_promise(store.get(key));
    };

    IndexedStore.prototype.add = function(store, val) {
      return request_to_promise(store.add(val));
    };

    IndexedStore.prototype.put = function(store, val) {
      return require_to_promise(store.put(val));
    };

    IndexedStore.prototype.del = function(store, key) {
      return require_to_promise(store["delete"](key));
    };

    IndexedStore.prototype.setup_database = function(db) {
      var store;
      console.log('*** setting up database');
      store = db.createObjectStore('documents', {
        keyPath: '_id'
      });
      store.createIndex('collection', 'collection', {
        unique: false
      });
      return void 0;
    };

    IndexedStore.prototype.open = function() {
      var _this = this;
      console.log('*** opening database');
      return this.open_database('Meteor.BrowserCollection', 1, function(db) {
        return _this.setup_database(db);
      }).then(function(db) {
        _this.idb = db;
        return void 0;
      });
    };

    IndexedStore.prototype.dump = function() {
      var _this = this;
      return this.transaction(function(tx) {
        var documents, req;
        documents = tx.objectStore('documents');
        console.log('documents', documents);
        req = documents.openCursor();
        req.onerror = function(event) {
          return console.log('dump error', event);
        };
        req.onsuccess = function(event) {
          var cursor;
          cursor = req.result;
          if (cursor != null) {
            console.log(cursor.value);
            return cursor["continue"]();
          }
        };
        return void 0;
      });
    };

    IndexedStore.prototype.fetch_all_docs = function(collectionName, tx) {
      var documents,
        _this = this;
      documents = tx.objectStore('documents');
      request_to_promise(documents.index('collection').openCursor(collectionName)).then(function(cursor) {
        console.log('have cursor', cursor);
        return void 0;
      });
      return _when.resolve([]);
    };

    IndexedStore.prototype.insert_doc = function(collectionName, tx, doc) {
      var documents;
      documents = tx.objectStore('documents');
      return this.add(documents, doc);
    };

    return IndexedStore;

  })();

  SQLStore = (function() {

    function SQLStore() {}

    SQLStore.prototype.open = function() {
      try {
        this.sqldb = openDatabase('Meteor.BrowserCollection', '', '', 1024 * 1024);
      } catch (e) {
        return _when.reject(e);
      }
      if (this.sqldb.version === '') {
        return this.setupDatabase();
      } else {
        return _when.resolve();
      }
    };

    SQLStore.prototype.setupDatabase = function() {
      var result,
        _this = this;
      result = _when.defer();
      this.sqldb.changeVersion('', '1', (function(tx) {
        tx.executeSql('CREATE TABLE documents (\
             id TEXT NOT NULL PRIMARY KEY,\
             collection TEXT NOT NULL,\
             document TEXT NOT NULL\
           )\
          ');
        return tx.executeSql('CREATE INDEX collections ON documents (collection)');
      }), (function(error) {
        console.log('create database error', error);
        return result.reject(error);
      }), (function() {
        return result.resolve();
      }));
      return result.promise;
    };

    SQLStore.prototype.transaction = function(withTransaction) {
      var deferred,
        _this = this;
      deferred = _when.defer();
      this.sqldb.transaction((function(tx) {
        _when(withTransaction(tx), null, (function(error) {
          return deferred.reject(error);
        }));
        return void 0;
      }), (function(error) {
        deferred.reject(error);
        return void 0;
      }), (function() {
        deferred.resolve();
        return void 0;
      }));
      return deferred.promise;
    };

    SQLStore.prototype.fetch_all_docs = function(collectionName, tx) {
      var deferred,
        _this = this;
      deferred = _when.defer();
      tx.executeSql('SELECT document FROM documents WHERE collection=?', [collectionName], (function(tx, result) {
        var docs, i, _i, _ref;
        docs = [];
        for (i = _i = 0, _ref = result.rows.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          docs.push(JSON.parse(result.rows.item(i).document));
        }
        return deferred.resolve(docs);
      }));
      return deferred.promise;
    };

    SQLStore.prototype.insert_doc = function(collectionName, tx, doc) {
      tx.executeSql('INSERT INTO documents (id, collection, document) VALUES (?, ?, ?)', [doc._id, collectionName, JSON.stringify(doc)]);
      return void 0;
    };

    return SQLStore;

  })();

  if (window.indexedDB != null) {
    store = new IndexedStore();
  } else if (window.openDatabase != null) {
    store = new SQLStore();
  } else {
    console.log('BrowserCollection storage not supported');
    store = null;
  }

  window.store = store;

  if (store != null) {
    store.open().otherwise(function(error) {
      console.log('BrowserCollection database open error', error);
      return store = null;
    });
  }

  collections = {};

  Meteor.BrowserMsg.listen({
    'Meteor.BrowserCollection.single': function(collection_name, doc_id) {
      var _ref;
      return (_ref = collections[collection_name]) != null ? _ref._reload_single(doc_id) : void 0;
    },
    'Meteor.BrowserCollection.reloadAll': function(collection_name) {
      var _ref;
      return (_ref = collections[collection_name]) != null ? _ref._reload_all() : void 0;
    }
  });

  Meteor.BrowserCollection = function(name, cb) {
    if (store == null) {
      throw new Error('BrowserCollection storage is not supported in this browser');
    }
    if (collections[name] != null) {
      throw new Error('a BrowserCollection with this name has already been created: ' + name);
    }
    this._name = name;
    this._localCollection = new LocalCollection();
    collections[name] = this;
    this._load(cb);
    return void 0;
  };

  each_sql_result = function(result, callback) {
    var i, _i, _ref, _results;
    _results = [];
    for (i = _i = 0, _ref = result.rows.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
      _results.push(callback(result.rows.item(i)));
    }
    return _results;
  };

  result_as_array = function(result) {
    var a, i, _i, _ref;
    a = [];
    for (i = _i = 0, _ref = result.rows.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
      a.push(result.rows.item(i));
    }
    return a;
  };

  idOf = function(doc) {
    return doc._id;
  };

  idMap = function(arrayOfDocs) {
    var doc, result, _i, _len;
    result = {};
    for (_i = 0, _len = arrayOfDocs.length; _i < _len; _i++) {
      doc = arrayOfDocs[_i];
      result[idOf(doc)] = doc;
    }
    return result;
  };

  _.extend(Meteor.BrowserCollection.prototype, {
    _load: function(cb) {
      var _this = this;
      return store.transaction((function(tx) {
        return store.fetch_all_docs(_this._name, tx).then(function(docs) {
          var doc, _i, _len;
          for (_i = 0, _len = docs.length; _i < _len; _i++) {
            doc = docs[_i];
            _this._localCollection.insert(doc);
          }
          return void 0;
        });
      })).then((function() {
        if (typeof cb === "function") {
          cb();
        }
        return void 0;
      }), (function(error) {
        console.log('BrowserCollection load transaction error', error);
        if (error.stack != null) {
          console.log(error.stack);
        }
        if (typeof cb === "function") {
          cb(error);
        }
        return void 0;
      }));
    },
    _cache_set: function(doc_id, doc) {
      if (doc != null) {
        if (this._localCollection.findOne(doc._id) != null) {
          this._localCollection.update(doc._id, doc);
        } else {
          this._localCollection.insert(doc);
        }
      } else {
        this._localCollection.remove(doc_id);
      }
      return void 0;
    },
    _reload_single: function(doc_id) {
      var doc,
        _this = this;
      doc = null;
      return store.sqldb.transaction((function(tx) {
        return tx.executeSql('SELECT document FROM documents WHERE collection=? AND id=?', [_this._name, doc_id], (function(tx, result) {
          if (result.rows.length === 1) {
            return doc = JSON.parse(result.rows.item(0).document);
          }
        }));
      }), (function(error) {
        return console.log(error);
      }), (function() {
        return _this._cache_set(doc_id, doc);
      }));
    },
    _fetch_all_docs: function(tx, cb) {
      var _this = this;
      return tx.executeSql('SELECT document FROM documents WHERE collection=?', [this._name], (function(tx, result) {
        var docs, i, _i, _ref;
        docs = [];
        for (i = _i = 0, _ref = result.rows.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          docs.push(JSON.parse(result.rows.item(i).document));
        }
        return cb(docs);
      }));
    },
    _update_doc: function(tx, doc) {
      return tx.executeSql('UPDATE documents SET document=? WHERE id=?', [JSON.stringify(doc), doc._id]);
    },
    _delete_doc: function(tx, doc_id) {
      return tx.executeSql('DELETE FROM documents WHERE id=?', [doc_id]);
    },
    _reload_all: function() {
      var docs,
        _this = this;
      docs = null;
      return store.sqldb.transaction((function(tx) {
        return _this._fetch_all_docs(tx, function(_docs) {
          return docs = _docs;
        });
      }), (function(error) {
        return console.log(error);
      }), (function() {
        var newResults, oldResults;
        oldResults = idMap(_this._localCollection.find().fetch());
        newResults = idMap(docs);
        return LocalCollection._diffQueryUnordered(oldResults, newResults, {
          added: function(newDoc) {
            return _this._localCollection.insert(newDoc);
          },
          changed: function(newDoc) {
            return _this._localCollection.update(newDoc._id, newDoc);
          },
          removed: function(oldDoc) {
            return _this._localCollection.remove(oldDoc._id);
          }
        });
      }));
    },
    insert: function(doc, callback) {
      var _this = this;
      if (doc._id != null) {
        throw new Error('inserted doc should not yet have an _id attribute');
      }
      doc._id = LocalCollection.uuid();
      store.transaction((function(tx) {
        return store.insert_doc(_this._name, tx, doc);
      })).then((function() {
        _this._localCollection.insert(doc);
        Meteor.BrowserMsg.send('Meteor.BrowserCollection.single', _this._name, doc._id);
        if (typeof callback === "function") {
          callback(null, doc._id);
        }
        return void 0;
      }), (function(error) {
        console.log('insert transaction error', error);
        if (typeof callback === "function") {
          callback(error);
        }
        return void 0;
      }));
      return doc._id;
    },
    find: function() {
      var arg, _ref;
      arg = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      return (_ref = this._localCollection).find.apply(_ref, arg);
    },
    findOne: function() {
      var arg, _ref;
      arg = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      return (_ref = this._localCollection).findOne.apply(_ref, arg);
    },
    _update_single: function(doc_id, modifier, options, callback) {
      var doc,
        _this = this;
      doc = null;
      return store.sqldb.transaction((function(tx) {
        return tx.executeSql('SELECT document FROM documents WHERE id=?', [doc_id], (function(tx, result) {
          if (result.rows.length !== 1) {
            return;
          }
          doc = JSON.parse(result.rows.item(0).document);
          LocalCollection._modify(doc, modifier);
          return _this._update_doc(tx, doc);
        }));
      }), (function(error) {
        console.log('modify transaction error', error);
        if (typeof callback === "function") {
          callback(error);
        }
        return void 0;
      }), (function() {
        _this._cache_set(doc_id, doc);
        Meteor.BrowserMsg.send('Meteor.BrowserCollection.single', _this._name, doc_id);
        if (typeof callback === "function") {
          callback();
        }
        return void 0;
      }));
    },
    _update_multiple: function(selector, modifier, options, callback) {
      var compiledSelector, modified_docs,
        _this = this;
      compiledSelector = LocalCollection._compileSelector(selector);
      modified_docs = [];
      return store.sqldb.transaction((function(tx) {
        return _this._fetch_all_docs(tx, function(docs) {
          var doc, _i, _len;
          for (_i = 0, _len = docs.length; _i < _len; _i++) {
            doc = docs[_i];
            if (compiledSelector(doc)) {
              LocalCollection._modify(doc, modifier);
              _this._update_doc(tx, doc);
              modified_docs.push(doc);
              if (!(options != null ? options.multi : void 0)) {
                break;
              }
            }
          }
          return void 0;
        });
      }), (function(error) {
        console.log('update transaction error', error);
        if (typeof callback === "function") {
          callback();
        }
        return void 0;
      }), (function() {
        var doc, _i, _len;
        for (_i = 0, _len = modified_docs.length; _i < _len; _i++) {
          doc = modified_docs[_i];
          _this._localCollection.update(doc._id, doc);
        }
        Meteor.BrowserMsg.send('Meteor.BrowserCollection.reloadAll', _this._name);
        if (typeof callback === "function") {
          callback();
        }
        return void 0;
      }));
    },
    update: function(selector, modifier, options, callback) {
      if (_.isFunction(options)) {
        callback = options;
        options = {};
      }
      if (LocalCollection._selectorIsId(selector)) {
        this._update_single(selector, modifier, options, callback);
      } else {
        this._update_multiple(selector, modifier, options, callback);
      }
      return void 0;
    },
    _remove_single: function(doc_id, callback) {
      var _this = this;
      return store.sqldb.transaction((function(tx) {
        return _this._delete_doc(tx, doc_id);
      }), (function(error) {
        console.log('remove transaction error', error);
        if (typeof callback === "function") {
          callback();
        }
        return void 0;
      }), (function(tx, result) {
        _this._localCollection.remove(doc_id);
        Meteor.BrowserMsg.send('Meteor.BrowserCollection.single', _this._name, doc_id);
        if (typeof callback === "function") {
          callback();
        }
        return void 0;
      }));
    },
    _remove_multiple: function(selector, callback) {
      var compiledSelector, deleted,
        _this = this;
      compiledSelector = LocalCollection._compileSelector(selector);
      deleted = [];
      return store.sqldb.transaction((function(tx) {
        return _this._fetch_all_docs(tx, function(docs) {
          var doc, _i, _len;
          for (_i = 0, _len = docs.length; _i < _len; _i++) {
            doc = docs[_i];
            if (compiledSelector(doc)) {
              _this._delete_doc(tx, doc._id);
              deleted.push(doc._id);
            }
          }
          return void 0;
        });
      }), (function(error) {
        console.log('remove transaction error', error);
        if (typeof callback === "function") {
          callback(error);
        }
        return void 0;
      }), (function() {
        var doc_id, _i, _len;
        for (_i = 0, _len = deleted.length; _i < _len; _i++) {
          doc_id = deleted[_i];
          _this._localCollection.remove(doc_id);
        }
        Meteor.BrowserMsg.send('Meteor.BrowserCollection.reloadAll', _this._name);
        if (typeof callback === "function") {
          callback();
        }
        return void 0;
      }));
    },
    remove: function(selector, callback) {
      if (selector == null) {
        return;
      }
      if (LocalCollection._selectorIsId(selector)) {
        this._remove_single(selector, callback);
      } else {
        this._remove_multiple(selector, callback);
      }
      return void 0;
    }
  });

  Meteor.BrowserCollection.erase = function() {
    var done;
    done = _when.defer();
    if (!_.isEmpty(collections)) {
      throw new Error("call erase() before opening any collections");
    }
    store.sqldb.transaction((function(tx) {
      return tx.executeSql('DELETE FROM documents');
    }), (function(error) {
      console.log('erase transaction error', error);
      return done.reject(error);
    }), (function() {
      console.log('erase transaction success');
      return done.resolve();
    }));
    return done.promise;
  };

  Meteor.BrowserCollection.reset = function() {
    return collections = {};
  };

}).call(this);
