// Generated by CoffeeScript 1.4.0
(function() {
  var IndexedStore, SQLStore, catcherr, collections, debugLog, debugStringify, each_sql_result, errorLog, idMap, idOf, promize, request_to_promise, result_as_array, store, _when,
    __slice = [].slice;

  _when = this.when;

  debugStringify = function(x) {
    if (x instanceof DOMException) {
      return x.toString();
    } else if ((x != null ? x.stack : void 0) != null) {
      return JSON.stringify(x.message) + ":\n" + x.stack.toString();
    } else if (_.isString(x)) {
      return x;
    } else if (_.isUndefined(x)) {
      return 'undefined';
    } else if (_.isNull(x)) {
      return 'null';
    } else {
      try {
        return JSON.stringify(x);
      } catch (e) {
        return x.toString();
      }
    }
  };

  debugLog = errorLog = function() {
    var args;
    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    args = _.map(args, debugStringify);
    return console.log.apply(console, args);
  };

  catcherr = function(fn) {
    return _when.resolve().then(fn);
  };

  request_to_promise = function(req) {
    var deferred;
    deferred = _when.defer();
    req.onerror = function(event) {
      return deferred.reject();
    };
    req.onsuccess = function(event) {
      return deferred.resolve(req.result);
    };
    return deferred.promise;
  };

  promize = function(fn) {
    var deferred, req;
    deferred = _when.defer();
    req = null;
    try {
      req = fn();
    } catch (e) {
      errorLog('promize error', e);
      deferred.reject(e);
    }
    if (req != null) {
      req.onerror = function(event) {
        return deferred.reject();
      };
      req.onsuccess = function(event) {
        return deferred.resolve(req.result);
      };
    }
    return deferred.promise;
  };

  IndexedStore = (function() {

    function IndexedStore() {}

    IndexedStore.prototype.implementation = 'IndexedDB';

    IndexedStore.prototype.delete_database = function(database_name) {
      return request_to_promise(window.indexedDB.deleteDatabase(database_name));
    };

    IndexedStore.prototype.open_database = function(database_name, version, onUpgradeNeeded) {
      var req;
      req = window.indexedDB.open(database_name, version);
      req.onupgradeneeded = function(event) {
        return onUpgradeNeeded(event.target.result);
      };
      return request_to_promise(req);
    };

    IndexedStore.prototype.transaction = function(desc, withTransaction) {
      var deferred, tx, valueOrPromise,
        _this = this;
      deferred = _when.defer();
      debugLog(">> " + desc + " begin transaction");
      tx = this.idb.transaction(['documents'], 'readwrite');
      tx.oncomplete = function() {
        debugLog("<< " + desc + " transaction complete");
        return deferred.resolve();
      };
      tx.onerror = function(event) {
        errorLog('<< #{desc} transaction error', event);
        return deferred.reject(event.target.errorCode);
      };
      valueOrPromise = catcherr(function() {
        return withTransaction(tx);
      });
      _when(valueOrPromise, null, (function(error) {
        debugLog("-- " + desc + " error in transaction:", error);
        return deferred.reject(error);
      }));
      deferred.promise.then((function() {
        return debugLog("-- " + desc + " transaction promise resolved");
      }), (function(error) {
        return debugLog("-- " + desc + " transaction promise rejected:", error);
      }));
      return deferred.promise;
    };

    IndexedStore.prototype.get = function(store, key) {
      return request_to_promise(store.get(key));
    };

    IndexedStore.prototype.add = function(store, val) {
      return request_to_promise(store.add(val));
    };

    IndexedStore.prototype.put = function(store, val) {
      return promize(function() {
        return store.put(val);
      });
    };

    IndexedStore.prototype.del = function(store, key) {
      return promize(function() {
        return store["delete"](key);
      });
    };

    IndexedStore.prototype.setup_database = function(db) {
      var store;
      debugLog('*** setting up IndexDB database');
      store = db.createObjectStore('documents', {
        keyPath: 'id'
      });
      store.createIndex('collection', 'collection', {
        unique: false
      });
      return void 0;
    };

    IndexedStore.prototype.open = function() {
      var _this = this;
      debugLog('*** opening IndexDB database');
      return this.open_database('Meteor.BrowserCollection', 1, function(db) {
        return _this.setup_database(db);
      }).then(function(db) {
        _this.idb = db;
        return void 0;
      });
    };

    IndexedStore.prototype.dump = function() {
      var _this = this;
      return this.transaction('dump', function(tx) {
        var documents, req;
        documents = tx.objectStore('documents');
        req = documents.openCursor();
        req.onerror = function(event) {
          return errorLog('dump error', event);
        };
        req.onsuccess = function(event) {
          var cursor;
          cursor = req.result;
          if (cursor != null) {
            errorLog(cursor.value);
            return cursor["continue"]();
          }
        };
        return void 0;
      });
    };

    IndexedStore.prototype.fetch_all_docs = function(collectionName, tx) {
      var deferred, docs, documents, req;
      deferred = _when.defer();
      docs = [];
      documents = tx.objectStore('documents');
      req = documents.index('collection').openCursor(collectionName);
      req.onerror = function(event) {
        errorLog('fetch_all_docs error', event);
        return deferred.reject();
      };
      req.onsuccess = function(event) {
        var cursor;
        cursor = req.result;
        if (cursor != null) {
          docs.push(cursor.value.doc);
          cursor["continue"]();
        } else {
          deferred.resolve(docs);
        }
        return void 0;
      };
      return deferred.promise;
    };

    IndexedStore.prototype.fetch_doc_by_id = function(tx, collectionName, doc_id) {
      var documents,
        _this = this;
      documents = tx.objectStore('documents');
      return this.get(documents, doc_id).then(function(document) {
        return document.doc;
      });
    };

    IndexedStore.prototype.insert_doc = function(collectionName, tx, doc) {
      var documents;
      documents = tx.objectStore('documents');
      return this.add(documents, {
        id: doc._id,
        collection: collectionName,
        doc: doc
      });
    };

    IndexedStore.prototype.update_doc = function(tx, collectionName, doc) {
      var _this = this;
      return catcherr(function() {
        var documents;
        documents = tx.objectStore('documents');
        return _this.put(documents, {
          id: doc._id,
          collection: collectionName,
          doc: doc
        });
      });
    };

    IndexedStore.prototype.delete_doc = function(tx, doc_id) {
      var _this = this;
      return catcherr(function() {
        var documents;
        documents = tx.objectStore('documents');
        return _this.del(documents, doc_id);
      });
    };

    IndexedStore.prototype.erase_database = function() {
      var _this = this;
      return this.transaction('erase_database', function(tx) {
        var documents, req;
        documents = tx.objectStore('documents');
        req = documents.openCursor();
        req.onerror = function(event) {
          return errorLog('erase_database error', event);
        };
        req.onsuccess = function(event) {
          var cursor;
          cursor = req.result;
          if (cursor != null) {
            documents["delete"](cursor.key);
            return cursor["continue"]();
          }
        };
        return void 0;
      });
    };

    return IndexedStore;

  })();

  SQLStore = (function() {

    function SQLStore() {}

    SQLStore.prototype.implementation = 'SQL';

    SQLStore.prototype.open = function() {
      try {
        this.sqldb = openDatabase('Meteor.BrowserCollection', '', '', 1024 * 1024);
      } catch (e) {
        return _when.reject(e);
      }
      if (this.sqldb.version === '') {
        return this.setupDatabase();
      } else {
        return _when.resolve();
      }
    };

    SQLStore.prototype.setupDatabase = function() {
      var result,
        _this = this;
      result = _when.defer();
      this.sqldb.changeVersion('', '1', (function(tx) {
        tx.executeSql('CREATE TABLE documents (\
             id TEXT NOT NULL PRIMARY KEY,\
             collection TEXT NOT NULL,\
             document TEXT NOT NULL\
           )\
          ');
        return tx.executeSql('CREATE INDEX collections ON documents (collection)');
      }), (function(error) {
        errorLog('create database error', error);
        return result.reject(error);
      }), (function() {
        return result.resolve();
      }));
      return result.promise;
    };

    SQLStore.prototype.transaction = function(desc, withTransaction) {
      var deferred,
        _this = this;
      if (!_.isFunction(withTransaction)) {
        throw new Error('withTransaction should be a function');
      }
      deferred = _when.defer();
      this.sqldb.transaction((function(tx) {
        _when(withTransaction(tx), null, (function(error) {
          return deferred.reject(error);
        }));
        return void 0;
      }), (function(error) {
        deferred.reject(error);
        return void 0;
      }), (function() {
        deferred.resolve();
        return void 0;
      }));
      return deferred.promise;
    };

    SQLStore.prototype.fetch_all_docs = function(collectionName, tx) {
      var deferred,
        _this = this;
      deferred = _when.defer();
      tx.executeSql('SELECT document FROM documents WHERE collection=?', [collectionName], (function(tx, result) {
        var docs, i, _i, _ref;
        docs = [];
        for (i = _i = 0, _ref = result.rows.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          docs.push(JSON.parse(result.rows.item(i).document));
        }
        return deferred.resolve(docs);
      }));
      return deferred.promise;
    };

    SQLStore.prototype.fetch_doc_by_id = function(tx, collectionName, doc_id) {
      var deferred,
        _this = this;
      deferred = _when.defer();
      tx.executeSql('SELECT document FROM documents WHERE collection=? AND id=?', [collectionName, doc_id], (function(tx, result) {
        if (result.rows.length === 1) {
          deferred.resolve(JSON.parse(result.rows.item(0).document));
        } else {
          deferred.resolve(null);
        }
        return void 0;
      }));
      return deferred.promise;
    };

    SQLStore.prototype.insert_doc = function(collectionName, tx, doc) {
      tx.executeSql('INSERT INTO documents (id, collection, document) VALUES (?, ?, ?)', [doc._id, collectionName, JSON.stringify(doc)]);
      return void 0;
    };

    SQLStore.prototype.update_doc = function(tx, collectionName, doc) {
      tx.executeSql('UPDATE documents SET document=? WHERE id=?', [JSON.stringify(doc), doc._id]);
      return void 0;
    };

    SQLStore.prototype.delete_doc = function(tx, doc_id) {
      tx.executeSql('DELETE FROM documents WHERE id=?', [doc_id]);
      return void 0;
    };

    SQLStore.prototype.erase_database = function() {
      var deferred;
      deferred = _when.defer();
      this.sqldb.transaction((function(tx) {
        return tx.executeSql('DELETE FROM documents');
      }), (function(error) {
        errorLog('erase transaction error', error);
        return deferred.reject(error);
      }), (function() {
        return deferred.resolve();
      }));
      return deferred.promise;
    };

    SQLStore.prototype.dump = function() {
      return _when.resolve();
    };

    return SQLStore;

  })();

  if (window.indexedDB != null) {
    store = new IndexedStore();
  } else if (window.openDatabase != null) {
    store = new SQLStore();
  } else {
    errorLog('BrowserCollection storage not supported');
    store = null;
  }

  window.store = store;

  if (store != null) {
    store.open().otherwise(function(error) {
      errorLog('BrowserCollection database open error', error);
      return store = null;
    });
  }

  collections = {};

  Meteor.BrowserMsg.listen({
    'Meteor.BrowserCollection.single': function(collection_name, doc_id) {
      var _ref;
      return (_ref = collections[collection_name]) != null ? _ref._reload_single(doc_id) : void 0;
    },
    'Meteor.BrowserCollection.reloadAll': function(collection_name) {
      var _ref;
      return (_ref = collections[collection_name]) != null ? _ref._reload_all() : void 0;
    }
  });

  Meteor.BrowserCollection = function(name, cb) {
    if (store == null) {
      throw new Error('BrowserCollection storage is not supported in this browser');
    }
    if (collections[name] != null) {
      throw new Error('a BrowserCollection with this name has already been created: ' + name);
    }
    this._name = name;
    this._localCollection = new LocalCollection();
    collections[name] = this;
    this._load(cb);
    return void 0;
  };

  Meteor.BrowserCollection._store = store;

  each_sql_result = function(result, callback) {
    var i, _i, _ref, _results;
    _results = [];
    for (i = _i = 0, _ref = result.rows.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
      _results.push(callback(result.rows.item(i)));
    }
    return _results;
  };

  result_as_array = function(result) {
    var a, i, _i, _ref;
    a = [];
    for (i = _i = 0, _ref = result.rows.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
      a.push(result.rows.item(i));
    }
    return a;
  };

  idOf = function(doc) {
    return doc._id;
  };

  idMap = function(arrayOfDocs) {
    var doc, result, _i, _len;
    result = {};
    for (_i = 0, _len = arrayOfDocs.length; _i < _len; _i++) {
      doc = arrayOfDocs[_i];
      result[idOf(doc)] = doc;
    }
    return result;
  };

  _.extend(Meteor.BrowserCollection.prototype, {
    _load: function(cb) {
      var docs,
        _this = this;
      docs = null;
      return store.transaction('_load', (function(tx) {
        return store.fetch_all_docs(_this._name, tx).then(function(_docs) {
          return docs = _docs;
        });
      })).then((function() {
        var doc, _i, _len;
        for (_i = 0, _len = docs.length; _i < _len; _i++) {
          doc = docs[_i];
          _this._localCollection.insert(doc);
        }
        if (typeof cb === "function") {
          cb();
        }
        return void 0;
      }), (function(error) {
        errorLog('BrowserCollection load transaction error', error);
        if (error.stack != null) {
          errorLog(error.stack);
        }
        if (typeof cb === "function") {
          cb(error);
        }
        return void 0;
      }));
    },
    _cache_set: function(doc_id, doc) {
      if (doc != null) {
        if (this._localCollection.findOne(doc._id) != null) {
          this._localCollection.update(doc._id, doc);
        } else {
          this._localCollection.insert(doc);
        }
      } else {
        this._localCollection.remove(doc_id);
      }
      return void 0;
    },
    _reload_single: function(doc_id) {
      var doc,
        _this = this;
      doc = null;
      return store.transaction('_reload_single', (function(tx) {
        store.fetch_doc_by_id(tx, _this._name, doc_id).then(function(_doc) {
          doc = _doc;
          return void 0;
        });
        return void 0;
      })).then((function() {
        _this._cache_set(doc_id, doc);
        return void 0;
      }), (function(error) {
        errorLog('_reload_single transaction error', error);
        return _when.reject(error);
      }));
    },
    _reload_all: function() {
      var docs,
        _this = this;
      docs = null;
      return store.transaction('_reload_all', function(tx) {
        return store.fetch_all_docs(_this._name, tx).then(function(_docs) {
          return docs = _docs;
        });
      }).then((function() {
        var newResults, oldResults;
        oldResults = idMap(_this._localCollection.find().fetch());
        newResults = idMap(docs);
        LocalCollection._diffQueryUnordered(oldResults, newResults, {
          added: function(newDoc) {
            return _this._localCollection.insert(newDoc);
          },
          changed: function(newDoc) {
            return _this._localCollection.update(newDoc._id, newDoc);
          },
          removed: function(oldDoc) {
            return _this._localCollection.remove(oldDoc._id);
          }
        });
        return void 0;
      }), (function(error) {
        return errorLog('_reload_all transaction error', error);
      }));
    },
    insert: function(doc, callback) {
      var _this = this;
      if (doc._id != null) {
        throw new Error('inserted doc should not yet have an _id attribute');
      }
      doc._id = LocalCollection.uuid();
      store.transaction('insert', (function(tx) {
        return store.insert_doc(_this._name, tx, doc);
      })).then((function() {
        _this._localCollection.insert(doc);
        Meteor.BrowserMsg.send('Meteor.BrowserCollection.single', _this._name, doc._id);
        if (typeof callback === "function") {
          callback(null, doc._id);
        }
        return void 0;
      }), (function(error) {
        errorLog('insert transaction error', error);
        if (typeof callback === "function") {
          callback(error);
        }
        return void 0;
      }));
      return doc._id;
    },
    find: function() {
      var arg, _ref;
      arg = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      return (_ref = this._localCollection).find.apply(_ref, arg);
    },
    findOne: function() {
      var arg, _ref;
      arg = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      return (_ref = this._localCollection).findOne.apply(_ref, arg);
    },
    _update_single: function(doc_id, modifier, options, callback) {
      var doc,
        _this = this;
      doc = null;
      return store.transaction('_update_single', (function(tx) {
        return store.fetch_doc_by_id(tx, _this._name, doc_id).then(function(_doc) {
          doc = _doc;
          LocalCollection._modify(doc, modifier);
          return store.update_doc(tx, _this._name, doc);
        });
      })).then((function() {
        _this._cache_set(doc_id, doc);
        Meteor.BrowserMsg.send('Meteor.BrowserCollection.single', _this._name, doc_id);
        if (typeof callback === "function") {
          callback();
        }
        return void 0;
      }), (function(error) {
        errorLog('update transaction error', error);
        if (typeof callback === "function") {
          callback(error);
        }
        return void 0;
      }));
    },
    _update_multiple: function(selector, modifier, options, callback) {
      var compiledSelector, modified_docs,
        _this = this;
      compiledSelector = LocalCollection._compileSelector(selector);
      modified_docs = [];
      return store.transaction('_update_multiple', (function(tx) {
        return store.fetch_all_docs(_this._name, tx).then(function(docs) {
          var doc, _i, _len;
          for (_i = 0, _len = docs.length; _i < _len; _i++) {
            doc = docs[_i];
            if (compiledSelector(doc)) {
              LocalCollection._modify(doc, modifier);
              store.update_doc(tx, _this._name, doc);
              modified_docs.push(doc);
              if (!(options != null ? options.multi : void 0)) {
                break;
              }
            }
          }
          return void 0;
        });
      })).then((function() {
        var doc, _i, _len;
        for (_i = 0, _len = modified_docs.length; _i < _len; _i++) {
          doc = modified_docs[_i];
          _this._localCollection.update(doc._id, doc);
        }
        Meteor.BrowserMsg.send('Meteor.BrowserCollection.reloadAll', _this._name);
        if (typeof callback === "function") {
          callback();
        }
        return void 0;
      }), (function(error) {
        errorLog('update transaction error', error);
        if (typeof callback === "function") {
          callback();
        }
        return void 0;
      }));
    },
    update: function(selector, modifier, options, callback) {
      if (_.isFunction(options)) {
        callback = options;
        options = {};
      }
      if (LocalCollection._selectorIsId(selector)) {
        this._update_single(selector, modifier, options, callback);
      } else {
        this._update_multiple(selector, modifier, options, callback);
      }
      return void 0;
    },
    _remove_single: function(doc_id, callback) {
      var _this = this;
      store.transaction('_remove_single', function(tx) {
        return store.delete_doc(tx, doc_id);
      }).then((function() {
        _this._localCollection.remove(doc_id);
        Meteor.BrowserMsg.send('Meteor.BrowserCollection.single', _this._name, doc_id);
        if (typeof callback === "function") {
          callback();
        }
        return void 0;
      }), (function(error) {
        errorLog('remove transaction error', error);
        if (typeof callback === "function") {
          callback(error);
        }
        return void 0;
      }));
      return void 0;
    },
    _remove_multiple: function(selector, callback) {
      var compiledSelector, deleted,
        _this = this;
      compiledSelector = LocalCollection._compileSelector(selector);
      deleted = [];
      return store.transaction('_remove_multiple', function(tx) {
        return store.fetch_all_docs(_this._name, tx).then(function(docs) {
          var doc, _i, _len;
          for (_i = 0, _len = docs.length; _i < _len; _i++) {
            doc = docs[_i];
            if (compiledSelector(doc)) {
              store.delete_doc(tx, doc._id);
              deleted.push(doc._id);
            }
          }
          return void 0;
        });
      }).then((function() {
        var doc_id, _i, _len;
        for (_i = 0, _len = deleted.length; _i < _len; _i++) {
          doc_id = deleted[_i];
          _this._localCollection.remove(doc_id);
        }
        Meteor.BrowserMsg.send('Meteor.BrowserCollection.reloadAll', _this._name);
        if (typeof callback === "function") {
          callback();
        }
        return void 0;
      }), (function(error) {
        errorLog('remove transaction error', error);
        if (typeof callback === "function") {
          callback(error);
        }
        return void 0;
      }));
    },
    remove: function(selector, callback) {
      if (selector == null) {
        return;
      }
      if (LocalCollection._selectorIsId(selector)) {
        this._remove_single(selector, callback);
      } else {
        this._remove_multiple(selector, callback);
      }
      return void 0;
    }
  });

  Meteor.BrowserCollection.erase_database = function() {
    if (!_.isEmpty(collections)) {
      throw new Error("call erase_database() before opening any collections");
    }
    return store.erase_database();
  };

  Meteor.BrowserCollection.reset = function() {
    return collections = {};
  };

}).call(this);
